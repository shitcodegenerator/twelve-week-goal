
```table-of-contents
```
到 Week 1 結束，你的 repo 必須能展示這 6 件事：

1. **Multi-tenant 路由落地**：`/t/[tenantSlug]/...` 跑得通，且會把 tenantSlug 變成 request scope
    
2. **Public / Host 分區清楚**：`app/(public)` 與 `app/(host)`、`/host/orders` 頁存在
    
3. **Host Orders Page**：用你做的 DataTable/FilterBar/StatusBadge 組成一頁（先用 mock data）
    
4. **TypeScript 嚴格化與基本工程化**：`strict`、eslint 基本規則、無 any 擴散
    
5. **最小可跑測試**：至少 3 個 unit tests（Vitest + RTL）
    
6. **文件能被第三人跑起來**：README v0 + ADR-000（multi-tenant 策略）
    

---

## Week 1（合併版）Day1–Day7：逐日清單（照做即可）

> 每天都會產生一個「可提交 PR」的切片，你可以用 Git 分支練習：`day1-bootstrap`、`day2-routing`…

### Day 1｜專案初始化 + 工程化基線（跑起來）

**目標**：專案能 `pnpm dev` 跑起來 + 基本規範到位

- 建 Next.js（App Router）+ TypeScript
    
- 開 TS strict
    
- ESLint（最小集合）＋ Prettier（可選，但建議）
    
- 建資料夾骨架（先空也沒關係）：
    
    - `app/(public)/t/[tenantSlug]/campaign/[campaignId]/page.tsx`
        
    - `app/(host)/host/dashboard/page.tsx`
        
    - `app/(host)/host/orders/page.tsx`
        
    - `lib/`、`docs/`
        

**交付物**

- 三個頁面都能開，顯示 placeholder
    
- `README.md` 先寫「如何啟動」與 env placeholder
    

---

### Day 2｜Multi-tenant routing & scope（把 tenant 變成「必帶上下文」）

**目標**：你不是只有 URL 長得像多租戶，而是「程式上真的有 tenant scope」

- 決定 tenant 來源：**只認 path param tenantSlug**
    
- 建 `lib/tenant.ts`
    
    - 解析 tenantSlug
        
    - 先 mock 一個 tenant（或用 in-memory map）
        
- 在 public page 把 tenantSlug 顯示出來，證明 scope 有進來
    
- 建 `docs/ADR-000-multi-tenant.md`（先草稿）
    

**交付物**

- `/t/demo/campaign/1` 顯示：tenant = demo, campaignId=1
    
- ADR-000 有「選型 + 風險 + 替代方案」三段
    

---

### Day 3｜Host Orders Page（先用 mock data）+ StatusBadge

**目標**：後台有一頁像真的，哪怕資料是假

- 建 order status enum（Pending/Paid/Shipped/Cancelled…）
    
- `StatusBadge` 元件（type-safe）
    
- Host orders page 用 mock orders array
    
- 顯示：訂單編號、客戶、金額、狀態、建立時間

#### （補強）— hooks 1：useState + derived state

你在 `/host/orders` 做 mock list 時，強制加這個驗收：

**新增任務**

- Filter 狀態必須由 `useState` 管理（keyword/status/date）
    
- `filteredOrders` **不准放 state**，必須是 derived（用 function 或 useMemo 推導）
    

**驗收點**

- ✅ 你能解釋：「為什麼 filteredOrders 不用 useState？」（避免 double source of truth）
    

**交付物**

- `/host/orders` 有一張表（先不用 DataTable 泛型，先硬寫也可，但要準備 Day4 抽出來）

    

---

### Day 4｜DataTable（泛型）抽象化 + FilterBar（狀態/日期/關鍵字）

**目標**：把 Day3 那坨硬寫抽成可擴充元件

- `DataTable<T>`：
    
    - columns：`{ key, header, render? }`
        
    - rows：T[]
        
- `FilterBar`：
    
    - keyword input
        
    - status select
        
    - date range（先簡化成 start/end input 也行）
        
- Orders page 整合：
    
    - FilterBar 改變 state → table 顯示 filtered data（client-side）

#### （補強）— hooks 2：useEffect + URL 同步（你會真的學到 useEffect）

你原本 Day4 是 DataTable + FilterBar，我把它補成「必須做 URL query 同步」。


**新增任務**

- FilterBar 的狀態（keyword/status）要同步到 URL query：
    
    - 例：`/host/orders?keyword=amy&status=PAID`
        
- 初次進頁面要能從 URL 讀回狀態（這裡會用到 useEffect 或初始化讀取）
    
- 加一個 debounce（200–300ms）避免每打字就 push URL（會用到 cleanup）
    

**你會學到**

- useEffect dependency array
    
- cleanup（clearTimeout）
    
- router replace vs push（避免歷史紀錄爆炸）
    

**驗收點**

- ✅ 重新整理頁面 filter 不會消失
    
- ✅ 你能解釋 cleanup 在防什麼 bug（debounce 未清除）

#### （補強）— hooks 3：useMemo / useCallback（不是背名詞，是解決 rerender）

在 OrdersPage 做兩個小優化示範：

**新增任務**

- `filteredOrders` 用 `useMemo` 包起來（依賴 keyword/status/date/orders）
    
- `onFilterChange` 用 `useCallback` 包起來（依賴 setState）
    
- 在 DataTable/FilterBar 用 `React.memo`（可選）觀察 rerender（你可以加 console.log）
    

**驗收點**

- ✅ 你能回答：「useMemo/useCallback 什麼時候不該用？」  
    （答：過度優化、依賴錯會引入 bug、維護成本）
        

**交付物**

- 你可以在 `/host/orders`：
    
    - 打關鍵字 → 列表縮小
        
    - 切狀態 → 列表縮小
        

---

### Day 5｜Testing（Vitest + React Testing Library）三個測試落地

**目標**：你能在履歷寫 “unit testing (RTL/Vitest)”

最低必做 3 測試：

1. StatusBadge：不同 status 顯示不同文字/樣式
    
2. FilterBar：輸入 keyword 會觸發 onChange
    
3. DataTable：給 columns + rows 能 render 出 header 與 cell
    

**交付物**

- `pnpm test` 綠燈
    
- `README` 增加 Testing 指令
    

---

### Day 6｜收斂「文件化」：README v0 + ADR-000 完整化 + Vue→React 對照筆記

#### （補強）— 狀態管理：props drilling vs context（做一次最小示範）

你不需要上 Redux/Zustand，但你要能「說得出口」。

**新增任務**

- 做一個 `TenantProvider`（React Context）：
    
    - 在 public page 讀 tenantSlug → 取得 tenant → 放進 context
        
    - 任一 child component 能取到 tenant（不用一直 props 傳下去）
        

**你會學到**

- Context 的使用情境（跨層級共享、但更新頻繁會導致 rerender）
    
- props drilling 的成本與替代方案
    

**驗收點**

- ✅ 你能解釋「為什麼現在不用狀態庫？」  
    （答：狀態共享範圍小、寫入者少、複雜度不足以引入 store）

**目標**：讓第三人能 clone 你 repo 跑起來，並看懂你的選型

- README v0（必備章節）
    
    - Quick start
        
    - Routes（public/host）
        
    - Tenant strategy（短版）
        
    - Scripts（dev/test/build）
        
- ADR-000：補上
    
    - “為何 shared schema + tenant_id”
        
    - “如何避免 tenant data leak”（service 層 scope、未來 RLS）
        
- `docs/vue-to-react-notes.md`：
    
    - reactive vs state
        
    - computed/watch vs memo/effect
        
    - component props / emits vs props/callback
        

---

### Day 7｜整體驗收 + 小幅 refactor（消滅 any、補型別邊界）

**目標**：把 Week 1 變成「可展示的一週成果」

- 全 repo 搜尋 `any` → 只留在你能解釋的地方（最好 0）
    
- Orders mock data 抽成 `lib/mock/orders.ts`
    
- Orders status type 抽成 `lib/domain/order.ts`
    
- 最後錄 1 分鐘 demo（可選，但很加分）
    
    - public route 開一下
        
    - host/orders filter 一下
        
    - test 指令跑一下



##  21 題驗收（精煉版）

### A) Multi-tenant / SaaS 架構

1. 什麼是 multi-tenant？
    
2. shared schema + tenant_id 的優缺點？
    
3. schema-per-tenant 的優缺點？
    
4. 如何避免 tenant 資料外洩（在 service layer）？
    
5. 前端路由如何承載 tenant（subdomain vs path）的取捨？
    
6. SaaS 的 “tenant onboarding” 怎麼做？
    

### B) Next.js（App Router）/ React 基礎與設計

7. Next App Router 的 route group / layout 用途？
    
8. Server Component vs Client Component 差異？
    
9. React 的單向資料流是什麼？
    
10. controlled vs uncontrolled input 差異？
    
11. useEffect 依賴陣列常見 bug？
    
12. 何時用 useMemo / useCallback（不要濫用）？
    
13. React key 為什麼重要？
    
14. props drilling 怎麼處理（先不用上狀態庫）？
    
15. 什麼是 derived state？如何避免？
    
16. component boundary 怎樣算可維護？
    
17. 什麼是 a11y 基本要求（表單/按鈕/label）？
    

### C) TypeScript

18. TypeScript narrowing 是什麼？
    
19. 泛型 props 在 DataTable 的用途？
    
20. utility types（Pick/Omit/Record）常見使用場景？
    
21. 為什麼要 TypeScript strict？
    

### D) Testing

22. unit test 在測什麼？什麼不該測？
    
23. RTL 的測試哲學（從使用者角度）是什麼？
    

### E) 工程化 / 架構治理 / 交付

24. 什麼是 ADR？為什麼在專案中有價值？
    
25. 你會怎麼做 environment separation（dev/stage/prod）？
    
26. 什麼是 config drift？如何避免？
    
27. 什麼是 feature flag？何時需要？
    
28. 如何規劃 domain model（entities）？
    
29. order system 的核心 bounded context 是什麼？
    
30. 什麼叫做 “public surface area” 變大？
    
31. 什麼是最小可行產品（MVP）？
    
32. 你怎麼確定 scope 不爆？
    
33. 什麼是“工程化”在前端的意義？
    
34. 你如何設計 repo 結構以便擴充？
    
35. 如何把需求寫成可驗收的交付物？